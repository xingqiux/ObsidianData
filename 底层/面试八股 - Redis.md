# 使用场景

## 双写一致性：redis 作为缓存， mysql 的数据如何与 redis 的数据进行同步

问：redis 作为缓存， mysql 的数据如何与 redis 的数据惊进行同步

### 第一步
设置前提，介绍自己的业务背景需求 `一致性要求高`还是 `允许延迟一致`
### 第二步（一致性要求高） 


`双写一致性` : 当修改了数据库的数据同时也要更新缓存的数据，缓存和数据库的数据需要保持一致


![[Pasted image 20250318163226.png|700]]
#### 采用 **延迟双删** 操作
1. 读操作： 缓存命中直接返回；缓存未命中查询数据库，写入缓存，设定超时时间
2. 写操作：延迟双删![[Pasted image 20250318163356.png|775]]
	1. 先删除缓存还是先修改数据库都可能会导致缓存和数据库数据不一致
	2. 因为删除两次缓存可以有效的减少脏数据的风险，主要原因是第一次删除缓存，可以将旧数据删除，然后修改数据库，修改完成后再删除缓存，再将修改后的数据存入数据库即可一定程度减少脏数据风险
	3. 延迟是因为如果设置了数据库主从模式，需要从数据库同步完成，但是延迟的过程也可能会有脏数据风险


#### 采用 **读写锁** 操作(强一致性)

**读写锁**
`共享锁` : 读锁 readLock,加锁之后，其他线程可以共享读操作
`排他锁` : 独占锁 writeLock ，加锁之后阻塞其他线程的读写操作
![[Pasted image 20250318164103.png]]
读数据的时候使用共享锁读数据，写数据的时候添加排他锁，这个方法可以保证强一致性，但是性能不高，主要是通过 redisson 实现的

### 第二步（允许延迟一致）

#### 采用 **异步通知** 保证数据的最终一致性
![[Pasted image 20250318164543.png|525]]
修改数据写入到 MySQL 以后就会发一条信息给 MQ ，缓存服务 cache-service 监听接收到 MQ 消息，然后更新缓存

虽然有延迟，但是最终还是会更新缓存

#### 采用 Canal 的异步通知
主要使用 MySQL 的主从同步实现的

![[Pasted image 20250318183115.png|625]]

监听 binlog 的二进制日志文件
优点是：对代码几乎不进行侵入

---
## 持久化问题：redis 作为缓存其持久化是怎么做的

`RDB` 全称 Redis Database Backup file （Redis 数据备份文件） ,也成为 Redis 数据快照，简单来说就是把内存中的所有数据记录到磁盘中，当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据

一共由 RDB 和 AOF 两种方式
### 命令方式
**手动触发**
`save` 由 Redis 主进程来执行 RDB，会阻塞所有命令
`bgsave` 开启子进程执行 RDB，避免主进程受到影响

### RDB 执行原理

bgsave 开始会 fork 主进程的到子进程，子进程 共享 主进程的内存数据。完成 fork 后读取内存数据并写入 RDB 文件 ![[Pasted image 20250318191844.png|675]]
**流程：** 
1. Redis 将数据存储在物理内存，但 redis 主进程则是通过**页表**，即虚拟地址与物理地址的映射关系进行读写操作
2. 当使用 bgsave 命令开始时会 fork 主进程到子进程，也就相当于复制了一份页表给子进程
3. 子进程就可以通过页表读取物理内存的数据进行备份到磁盘替换旧 RDB 文件。

其中，如果子进程在备份的时候主进程仍然在写入则可能出现脏数据问题，所以当 fork 的同时会设置物理内存的数据为 read-only 模式，这也就是 fork 采用的 copy-on-write 技术
**copy-on-write 技术**
- 当主进程进行读操作时可以访问共享物理内存
- 当主进程进行写操作时，会拷贝一份数据，然后再数据的拷贝上执行 写操作

### AOF 方式

AOF 全称 Append Only File (追加文件)。Redis 处理的每一个写命令都会记录在 AOF 文件中，可以看作时命令日志文件

#### 开启 AOF

在 `redis.conf` 配置文件中开启 AOF
![[Pasted image 20250318192940.png]]

AOF 的命令记录的频率配置
![[Pasted image 20250318193034.png]]
一般在项目中都是设置 appendfsync everysec ，是默认方案

通过 `bgrewriteaof` 命令可以让 AOF 文件执行重写功能
![[Pasted image 20250318193312.png]]

### RDB 与 AOF 对比


|         | RDB                 | AOF                                   |
| ------- | ------------------- | ------------------------------------- |
| 持久化方式   | 定时对这个内存做快照          | 记录每一次执行的命令                            |
| 数据完整性   | 不完成，两次备份之间会有丢失      | 相对完整，取决于刷盘的策略                         |
| 文件大小    | 因为是二进制文件会进行压缩所以比较小  | 记录的是命令，文件见体积大                         |
| 宕机恢复速度  | 很快                  | 慢                                     |
| 数据恢复优先级 | 低，因为数据完整性不如AOF      | 高，数据完整性更高                             |
| 系统资源占用  | 较大，需要大量的 CPU 和内存消耗  | 低，主要吃磁盘IO资源<br>但 AOF 重写需要大量的CPU 和内存消耗 |
| 使用场景    | 可以忍受数分钟的数据丢失，追求启动速度 | 对数据安全性要求较高                            |
开发中往往结合两者一起使用

- **混合持久化**（Redis 4.0+）：开启`aof-use-rdb-preamble`，AOF文件包含RDB头+增量命令，兼顾恢复速度与数据安全。


---

## Redis 数据的过期策略

redis 中对数据设置有效期，过期就从内存中删除，而这些删除的规则就是数据的删除策略有 `惰性删除` 和 `定期删除`

### 惰性删除
设置该 key 过期时间后，不管它，当再次需要该 key 的时候再检查是否过去，如果过期就删掉否则返回该key

**优点**： 对 CPU 友好，用不到的 key 不会浪费时间进行过期检查
**缺点**：对内存不友好，如果一个 key 过期但一直没有用就会一直在内存中永不释放

### 定期删除
每隔一段时间对一些 key 进行检查，删除里面过期的 key

定期删除两种模式
- SLOW 模式是定时任务，执行频率默认为 10hz ，每次不超过 25ms, 通过修改配置文件 redis.conf 的 hz 选项来调整次数
- FAST 模式执行频率不固定，但两次间隔不低于 2ms ，每次耗时不超过 1ms

优点 ： 通过限制删除操作执行时长和频率来减少对 CPU 的影响。另外定期删除也能有效释放过期键占用的内存
缺点：难以确定删除执行的时长和频率

 **Redis 过期删除策略：惰性删除+定期删除两种策略配合使用**


---

## 数据淘汰策略 - 缓存过多，内存被占满了如何处理?

当 Redis 中的内存不够用，再添加新的 key，Redis 就会按照某种规则将内存中的数据删掉，这个规则就是数据淘汰策略

### 8种淘汰策略(不需要死记)

noeviction : 不淘汰任何 key，但内存满不会存储新数据，默认

有3个标签组成出6个策略，加上一个 ttl 策略

- **random** : 随机淘汰
- **lru** : 最少最近(Recently)使用，当前的时间减去最近访问的时间，数值越大淘汰优先级越高
- **lfu**：最少频率(Frequently)使用，统计每个key 的访问频率，值越小淘汰优先级越高
- **allkeys** ： 对全体 key
- **valatile** ： 对设置了 TTL 值的key
![[Pasted image 20250318204412.png|675]]

### 使用建议
1. 优先使用 allkeys-lru 策略。利用 LRU 的算法把最常访问的数据留在缓存中，如果业务有明显的冷热数据区分时建议使用
2. 如果业务访问频率不大，没有明显冷热数据区分，建议使用 allkeys-random 随机淘汰
3. 如果有置顶的数据，可以使用 volatile-lru 策略，然后不设置置顶数据的 ttl
4. 如果业务中有短时高频访问数据，可以使用带 lfu 的策略

### 其他面试题

#### 数据库有 1000万 条数据， Redis 只能缓存 20w 数据，如何保证 Redis 中的数据都是热点数据？

使用 allkeys-lru 最近最少使用的数据淘汰策略，以保证缓存中都是热点数据

#### Redis 的内存用完会发生什么？

主要看淘汰策略，不过如果是默认 noeviction 的策略会报错

---
