# 数据结构与算法

## 线性结构

**特点：每一个元素只有一个前驱和后继**

### 数组

#### 特点
- 长度不会改变
- 通过索引可以在O(1)时间访问元素
- 内存中是连续的

#### 数组类型与变种
1. **一维数组**
   - 最基础形式

2. **多维数组**
   - 包含二维数组和更高维度的数组，如三维数组
   - 多维数组的复杂度较高，存储访问均需多个索引

3. **稀疏数组**
   - 包含大量零元素的数组，为节省空间而进行特殊存储
   - 包含以下的矩阵类型：
     - 上三角矩阵
     - 下三角矩阵
     - 对角矩阵

4. **动态数组**
   - 大小可动态改变，常见实现包括向量（Vector）和链表（Linked List）
   - 需要特殊的内存管理技术（如倍增法）来优化性能

#### 操作
1. **读**
   - 直接通过下标读取，时间复杂度为O(1)

2. **查询**
   - 查询数值返回位置
   - 平均查询时间为O(n/2)
   - 最多查询n次

3. **插入**
   - 插入一个元素需要将其他元素后移
   - 平均插入时间为O(n/2)
   - 最多插入n次

4. **删除**
   - 删除一个元素需要将元素前移
   - 平均删除时间O(n/2)
   - 最多移动n-1次

#### 数组的地址计算
- **一维数组** a[n]
  - a[i]的存储地址为a + i * len

- **二维数组** a[m][n]
  - a[i][j] 的存储地址按行为 a+(i*n+j)*len
  - a[i][j] 的存储地址按列为 a+(j*m+i)*len

---

### 链表

#### 特点
- 逻辑上是相邻的物理上可能并不相邻
- 通过数据部分和指针变量构成，数据部分存储数据，地址部分用于指向下一个节点所在的位置
- 除了头结点尾结点每一个结点只有一个前驱和一个后继
- 头结点不存放有效数据只存放链表首地址
- 头结点目的是为了方便对链表的操作，比如在链表头部进行结点的删除，插入

#### 结构
![[885940f221d98ffc7ae73d655809c7054e0129b109a3d9f812c31e985ca7730f.png]]
- **尾结点**：最后一个有效节点
- **首结点**：第一个有效节点
- **头结点**：第一个有效节点前一个节点，存放链表首地址
- **头指针**：指向头结点的指针变量
- **尾指针**：指向尾结点的指针变量

#### 分类
![[84d361e5c5a2498d847ff11fbbb1b3049a42f940a4471d0c2fbfeab602c91cb7.png|450]]
- **单链表**：只有后继没有前驱
- **循环链表**：将尾指针指向头指针
- **双向链表**：有后继也有前驱

#### 基本操作
2. **查询**
   - 需要从头结点一直遍历到找到对应数据
   - 时间复杂度 O(n) ,头节点 O(1)

3. **删除**
   - 单链表
     - 一直找到需要删除结点的前驱结点，将前驱结点的next指向下一个结点的地址即可
   
   - 双链表
     - 将前驱结点的后继指针指向后继结点
     - 将后继结点的前驱指针指向前驱结点
 - 时间复杂度: 删除节点是 O(1)
		

3. **插入**
   - 单链表
     - 先将需要插入结点指向后继结点
     - 然后将插入结点的前驱结点指向插入结点
   
   - 双链表
     - 先新增指针指向
     - 再修改指针指向
 - 时间复杂度: 插入节点是 O(1)

#### 顺序和链式存储对比

![[3847e818b66ebb8220def3a096afe363f997502cd0607c8ee95b179d87c483c2 1.png|500]]

-----

### 栈

- **特点**：先入后出
- **单链表来设定**：*(原文此处无具体内容)*

---

### 队列

- **特点**：先进先出
- **经常用循环单链表设定**：*(原文此处无具体内容)*

#### 循环队列
- **队空条件**：head = tail
- **队满条件**：(tail + 1) % size = head
- **队列长度**：(tail - head + size) % size

---

### 串

- 仅由字符构成的有限序列

#### 概念
1. **空串与空格串**
   - 空串长度为0，不包含任何字符
   - 空格串由一个或多个空格组成

2. **子串与子序列**
   - 子串：任意长度连续字符构成的序列
   - 子序列：将其中的一些字符提取中获得的一个新串

3. **串比较与串相等**
   - 串比较：两个串中字符码值大的串大，如果一个串先结束，串长的更大
   - 两个串长度相等对应符号也相同

#### 模式匹配
- **朴素模式匹配算法**
- **KMP算法**
  - next数组求值

---

## 非线性结构

### 树

#### 概念
- 结点度
- 树度
- 叶子节点：无分支结点
- 分支结点
- 内部结点
- 父结点
- 子结点
- 兄弟结点
- 层次（高度）

#### 分类
![[27bae8e561c9040c922bf804ac034962e2aa8f3380007e44b4c3ffc7dea189b0.png]]
- 满二叉树
- 完全二叉树
- [[#二叉排序树|排序二叉树]]
- 红黑树

#### 二叉树重要特性
1. 二叉树第 i 层上有最多 2^(i - 1) 个结点，i>=1
2. 深度为k的二叉树最多有(2^k)-1个结点，k>=1
3. 对于任何一颗二叉树，如果叶子结点数为 n0，度为2的结点数为n2，则n0 = n2 + 1 
4. 如果对一颗 n 个结点的安全二叉树的结点按层序编号，从第1层到`[lon2n]+1`层，每层从左到右，对于任意结点i，有：
   - 如果i = 1，则结点i 无父节点，是树的根
   - 如果i > 1，则是父节点的i/2
   - 如果2i > n，则结点i为叶子节点，无左子节点，否则起左子结点是结点2i
   - 如果2i+1 > n，则结点i 无右子结点，否则右子结点的结点2i+1

#### 二叉树存储方式
- **顺序存储**：
![[aa 1.png]]

- **链式存储**
![[bb.png]]

#### 二叉排序树 

##### 原理

二叉排序树（Binary Search Tree,BST）又名二叉查找树，有序查找树或排序二叉树，是二叉树中比较常用的一种类型

主要是输在任意一个节点，左子树的的每个节点的值小于节点值，右子树的每个结点的值大于节点值

- 左孩子小于根
- 右孩子大于根

##### 时间复杂度
**插入，删除，查找的时间复杂度都是 O(logn)**
![[Pasted image 20250324112914.png]]

**特殊情况**
退化成链表，即所有的数都在左子树或右子树
![[Pasted image 20250324113058.png]]


#### 最优二叉树（哈夫曼树）
- 树的代价最小的二叉树
![[dec8aa128b31ad7e6bfadc3ebff275f5ba128a037cec5d04de0f9077c85e3a5a.png]]

#### 红黑树
##### 定义
红黑树(Red Black Tree) : 也是一种自平衡的二叉搜索树(BST)，之前也叫做平衡二叉树(Symmetric Binary B-tree)
![[Pasted image 20250324113417.png]]

##### 性质
1. 节点要么红要么黑
2. 根节点是黑色
3. 叶子节点都是黑色空节点
4. 红黑树中红色节点的子节点都是黑色
5. 从任一节点到叶子节点的路径都包含 **相同数目** 的黑色节点
不符合性质时会发生 **旋转**

**解析**
**设计隐喻**：
- **黑色节点**：代表"稳定节点"，在路径计算中具有重量感
- **红色节点**":缓冲节点"，用于在不破坏整体平衡的前提下允许局部不平衡
- **颜色交替规则**：类似交通信号灯，防止连续危险状态（两个红节点相连）
**颜色约束**：红黑交替的特性避免了路径长度差超过两倍
   - 红色节点不能连续（性质4）
   - 黑色完美平衡（性质5保证每条路径黑节点数相同）
**平衡保证**：最坏情况下树高不超过 2log₂(n+1)
   - 通过颜色约束和旋转操作实现近似平衡
   - 相比AVL树的严格平衡，维护成本更低

##### 时间复杂度
![[Pasted image 20250324114055.png]]

#### 散列表(哈希表)

##### 定义
哈希表又称散列表，根据键值 key 直接访问在内存存储的位置值 value 的数据结构，是由数组演化而来，利用了数组支持按照下标进行随机访问数据的特性

##### 散列函数
基本要求：
- 散列函数得到的值必须是大于等于0的正整数，因为需要作为数组的下标
- 如果 key1 == key2 ,那经过 hash() 函数计算 hash(key1) == hask(key2)
- 如果 key1 != key2 ,那经过 hash() 函数计算 hash(key1) != hask(key2)(如果相同的话就属于函数冲突)

##### 哈希冲突(哈希碰撞)
理想情况下每一个 key 都对应不同的 hash 值，但实际上例如 MD5 ，SHA 等哈希算法也可能会导致相同情况 ，这就属于哈希冲突（散列冲突）多个key映射到了同一个数组下标位置

##### 冲突解决 - 链表法
每个下标的位置可以称之为桶，每个桶都会对应一条链表，所有散列值相同的元素我们都会放到相同桶的链表中
![[Pasted image 20250324141322.png]]

时间复杂度：
插入操作O(1)
查找、删除一个元素：平均情况下是O(1) ,如果哈希冲突较多，就会退化成链表，时间复杂度就会降到 O(n )
(将链表改造成红黑树，查询时间复杂度为 O(logn) ，是 hashMap 的底层原理)
 


---


### 图

#### 图的基本概念
- **完全图**
  - 无向图：每一个顶点都有一条边相连
  - 有向图：每对顶点都有两条有向边相互连接
- **连通图**
  - 任意两个顶点之间都有一个路径相连

#### 图的存储
- 用n阶方阵来存储图的结点信息
  - 如果是对角线对称的，可能是无向图或者完全有向图
  - 如果不对称可能是有向图

#### 图的遍历
- **深度优先**
  - 对于一个结点找到其下一个结点一直查找直到找不到相关数据为止再返回重新查找
- **广度优先**
  - 一般是使用队列的方式实现，通过访问时访问相邻结点，然后将相邻结点的结果再放入队列中进行访问

#### 拓扑排序
- 图示：*(原文此处无具体内容)*

#### 图的最小（权值）生成树
- **克鲁斯卡尔算法**
  - 选择最小边的权值生成树
  - 如果出现环路则成为冗余边不计入
- **普利姆算法**
  - 从任意一个顶点开始，寻找权值最小的没有被加入结果集的顶点
  - 找到权值最小的顶点，加入结果集，从结果集的所有顶点出发再找最小的顶点
  - 以此类推找出所有的结点

#### 最短路径
- **迪杰斯特拉算法**
  - 通过达到每一个点的上一个的最短路径，将一整条线的问题转换成一个个点的问题考虑

---

## 算法

### 复杂度

#### 时间复杂度
- 算法所需要的时间规模
- **O(1)**：常量级别
- **O(n)**
- **O(n^2)**
- **O(log₂n)**：一般出现在树形结构和二分查找之类
- **O(nlog₂n)**：一般出现堆排序，每次重建堆的时间复杂度是log₂n，n个元素基本上就是nlog₂n
- **O(2^n)**：动态规划法自顶向下，LCS最长公共子序列

#### 空间复杂度
- 运行中占用的临时存储大小的度量
- 只考虑在局部变量分配的存储空间

---

### 算法策略

#### 分治法
- **概述**
  - 把一个问题拆分成多个小问题，一般用递归解决
  - 实例：斐波那契数列，归并排序，快速排序，二分搜索
- **过程**
  - 分解：
    - 将问题缩小到一定程度就可以容易的解决
    - 将问题缩小为若干相同问题
  - 解决：该问题解决
  - 合并：将小问题的解决合并起来就是大问题的解决

#### 贪心法
- 一般用于求满意解
- 局部最优，单整体不见得最有，每笔有明确策略
- 按照"最xx"的思路来进行解决

#### 动态规划法
- **概念**
  - 划分子问题，把子问题结果用数组存储，利用查询子问题结果构造最终问题结果。（一般自顶向下时间复杂度O(n^2)，自底向上时间复杂度为O(n^a)）
  - 用于求最优解--最优子结构和递归式
  - 具有最优问题解集合，单分支法没有
  - 矩阵乘法，背包问题，LCS最长公共子序列

#### 回溯法
- 系统的搜索一个问题的解
- n皇后问题
- **试探部分**
  - 满足除规模以外的所有条件，则扩大规模
- **回溯部分**
  - 当前规模不是合法解时回溯
  - 求完一个解，要求下一个解时也要回溯

---

### 查找算法

#### 顺序查找
- 平均查找长度 (n+1)/2

---

### 排序算法

#### 插入类
- 稳定
- 时间复杂度 O(n^2)
- 空间复杂度 O(1)

#### 堆排序
- 时间复杂度 O(nlog₂n)

#### 快速排序
- 时间复杂度 O(nlog₂n)
- 基本有序的最差情况时间复杂度为 O(n²)

#### 归并排序
- 时间复杂度 O(nlog₂n)

---