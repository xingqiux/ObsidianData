
## **集合框架面试题**
### **HashMap 原理**  

#### 底层数据结构与哈希冲突解决

- **底层数据结构**：数组+链表/红黑树，称为哈希桶(bucket)数组
- **哈希冲突解决**：通过拉链法，即同一个桶内的元素组成链表
- **链表转红黑树条件**：链表长度≥8 **且** 数组长度≥64才会转为红黑树
    - 如果链表长度≥8但数组长度<64，会优先选择扩容而非转红黑树
#### 扩容机制

- 有一个负载因子(load factor)，默认为0.75
- 当元素数量超过 `capacity * load factor` （类型 * 负载因子）时触发扩容
- 扩容过程：创建一个新数组，容量为原来的2倍
- 对所有元素重新计算哈希值并迁移到新数组(rehash过程)
- JDK 8优化：利用哈希值与旧容量按位与的结果，元素要么在原位置，要么在原位置+旧容量的位置

#### 为什么 HashMap 线程不安全
- **并发问题**：
    - JDK 7中，并发扩容可能导致链表形成环，造成死循环（扩容链表成环）
    - 并发写入可能导致数据覆盖或丢失（写入可能丢失）
    - 没有任何同步机制保证多线程下的数据一致性（没有同步机制）

### **ConcurrentHashMap**  

### **List 实现类对比**  
#### ArrayList 和 LinkedList 的底层结构、查询/插入性能差异？

- **ArrayList**：    
    - 底层是动态数组
    - 随机访问性能优秀，O(1)时间复杂度
    - 尾部添加元素一般为O(1)，但达到容量上限需要扩容
    - 中间插入删除需要移动元素，O(n)时间复杂度
    - 空间利用率高，但扩容需要整体复制，开销大
- **LinkedList**：
    - 底层是双向链表
    - 随机访问性能较差，O(n)时间复杂度
    - 已知位置的插入删除高效，O(1)时间复杂度
    - 无需扩容，但存储效率低，需额外存储前后节点引用

#### CopyOnWriteArrayList 的写时复制机制及适用场景？

- **写时复制机制**：
    - 每次写操作(add/set/remove)都会复制整个底层数组
    - 修改在新数组上进行，完成后将引用指向新数组
    - 读操作无锁，写操作需要获取独占锁
- **适用场景**：
    - 读多写少的场景
    - 集合规模较小
    - 需要线程安全但对实时性要求不高的场景
    - 如：事件监听器列表、观察者列表等

### **红黑树与二叉树优化**  
#### HashMap 为何在链表长度 ≥8 时转为红黑树？

- 红黑树的查询时间比链表的查询时间快 ，为 O(log n)
- 在哈希函数良好的时候 >= 8 的链表长度很少见
- 链表过长说明哈希冲突严重，所以使用红黑树可以提高性能

#### 退化为链表的阈值为什么是 6？

- 设置不同阈值是为了避免链表和红黑树之间频繁转换（为了不让他们频繁转换，会丢失性能和稳定性）
- 形成滞后效应(hysteresis)：链表长度在6-8之间时保持当前结构
- 防止在临界点反复震荡，提高稳定性和性能



## List  相关面试题

### ArrayList 相关

数组(Array) : 是一种用 **连续的内存空间** 存储 **相同数据类型** 数据的线性数据结构
 
#### 数据结构 - 数组

寻址公式

`a[i] = baseAddress + i * dataTypeSize`

baseAddress : 数组的首地址
dataTypeSize : 数组数据类型的大小，例如 int 值数据，dataTypeSzie = 4 字节

##### **问题：为什么数组索引从0开始，从1开始不行吗**

因为根据寻址公式，从0开始 0 * dataTypeSize 一定就是 baseAddress 的地址，也就是0根据这个公式一定是数组的首地址，所以使用0开始，，如果用1开始，就只能使用 `baseAddress + (i-1) * dataTypeSize` 对 CPU 来说就会多一次运算，性能不高

##### **问题：操作数组的时间复杂度**

查询
1. **根据索引查询** : O(1)
2. **无索引查询** : 顺序查询O(n)，二分查找O(logn)

插入，删除
O(n)

### ArrayList 源码分析
#### 构造方法
![[Pasted image 20250324091322.png|700]]

#### ArrayList 底层实现原理 

**问题：ArrayList 的底层是使用动态的数组实现的**

ArrayList 的初始容量为 0 ，当第一次添加数据时才会初始化容量为10
ArrayList 进行扩容时时原来容量的 1.5 倍，每次扩容都需要拷贝数组
ArrayList 添加数据时
- 确保数组已使用长度+1 足够存下下一个数据
- 计算数组的容量，如果当前数组的已使用长度+1后大于当前的数组长度，则调用 grow 方法扩容到原来长度的 1.5 倍
- 确保新增数组有地方存储后，将新元素添加到 size 的位置上
- 返回添加成功的布尔值 

**问题： ArrayList list = new ArrayList(10)中的 list 扩容了几次**

因为这个是声明和实例化了一个 ArrayList ，初始容量为10  ，所以并没有进行扩容

### LinkedList 相关

#### 数据结构 - 链表
[[笔记 - 数据结构与算法#链表|链表]]

#### ArrayList 与 LinkedList 的区别

1. **底层数据结构**
	- ArrayList 是动态数组的数据结构实现
	- LinkedList 是双向链表的数据结构表现 
2. 操作数据效率
	1. 查询
		- ArrayList 有下标，查询速度为 O(1) 
		- LinkedList 没有下标，查询速度为 O(n)
	2. 新增和删除
		- ArrayList 尾部插入和删除时间复杂度为 O(1) ，其他地方增删需要挪动数组为 O(n)
		- LinkedList 头尾节点增删时间复杂度O(1),其他地方需要遍历脸被我 O(n)
3. 空间的占用
	- ArrayList底层是数组，内存连续节省内存
	- LinkedList 是双向链表需要存储数据和两个指针，更占用内存
4. 这两者都不是线程安全

## HashMap 相关面试题

### 数据结构
#### 二叉树
[[笔记 - 数据结构与算法#树|二叉树]]
#### 红黑树
![[笔记 - 数据结构与算法#红黑树|红黑树]]

#### 散列表
![[笔记 - 数据结构与算法#散列表(哈希表)]]

#### 面试题目

##### HashMap 的实现原理

HashMap的数据结构：底层使用 hash 表数据结构，即数组，链表或红黑树

只有在链表长度大于8且数组长度大于64才会转换成红黑树

1. 当我们往 HashMap 中 put 元素时，利用 key 的 hashCode 重新计算 hash 计算出当前元素对应下标
2. 存储时，如果出现 hash 值相同的 key ，有两种情况
	a. 如果 key 值相同，则覆盖原值
	b. 如果 key 值同说明是出现冲突，则将 key-value 放入链表或者红黑树中
3. 获取时，找到 hash 值对应的下标，再进一步判断 key 是否相同，从而找到对应值

##### HashMap 的 1.7 和 jdk 1.8 的区别

- jdk1.7 之前采用 拉链法，数组+链表
- jdk1.8 之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64才会转换成红黑树

##### HashMap的 put 方法的具体流程
![[源码 - HashMap 源码分析]]

1. 判断键值对数组table是否为 null 或者 空，执行 resize() 进行初始化
2. 根据 key 计算 hash 值获得数组索引 i 
3. 如果 `table[i] = null` 说明没有数据则直接添加 
4. 如果  `table[i] = null` 不成立，说明有数据，进行判断
	1. 判断这个 key 是否存在，如果存在则直接覆盖 value
	2. 如果 key 不存在，则查看是否是红黑树，如果是红黑树则在红黑树中查找对应的key，如果有直接覆盖，如果没有则设置值
	3. 如果不是红黑树，则遍历链表，如果链表中存在则设置，如果不存在就不设置