# 如何定位慢查询

## 开源工具

Arthas、Prometheus、Skywalking
## MySQL 自带慢日志查询

慢日志查询记录了所有执行时间超过指定参数(long_query_time)的 SQL 语句
需要在 MySQL 的配置文件中进行配置 (/etc/my.cnf)

```json
slow_query_log=1 #1为开0为关
long_query_time=2 #秒
```
配置完成后重新启动，检测到慢查询就会记录到`/var/lib/mysql/localhost-slow.log`中

# 分析 SQL 语句执行慢的原因

## 获取 MySQL 执行 SELECT 语句的信息

可以使用 EXPLAIN 或者 DESC 命令获取 MySQL 执行 SELECT 语句的信息

```sql
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件
```

得到的信息是

![[Mysql - 优化.png]]

这里就是这个 SELECT 语句的执行信息，其中一部分字段是需要掌握的，是表示实际使用的索引和执行性能

- possible_key： 可能使用到的索引，这里是 `PROIMARY`

这两个属性可以查看是否命中索引
- key：实际使用的索引
- key_len：索引的实际长度

额外优化建议
- Extra：一共有两个参数，表示额外优化的建议
  ![[Mysql - 优化-1.png]]
  如果发生了 **回表查询** 是可以优化的

用于查看这条 SQL 的连接类型
- type：性能由好到差分别为
  NULL - 无查询
  system - 查询系统中的表
  const - 根据主键查询
  eq_ref - 主键索引查询或者唯一索引查询
  ref - 索引查询
  range - 范围查询
  index - 索引树查询
  all - 全盘扫描

# 索引

## 索引是什么

索引( `index` )是主要是帮助 MySQL 高效获取数据的数据结构(有序)

是一种数据库系统维护的 **满足特定查找算法** 的 **数据结构** （B+树），这种数据结构用某种方式引用数据，这样就可以实现高级的查找算法

具有以下特点
- 提高数据检索效率，降低数据库 IO 成本（不需要全盘扫描）
- 通过索引列对数据进行排序，降低数据排序成本，降低 CPU 负担

## 索引的原理

MySQL 的 InnoDB 存储引擎是使用 B+ 树实现索引结构的

### B 树

是一种多叉路平衡查找树，和二叉树相比有多个分支。

一个最大度数（max-degree）为5阶的b树来说，每一个节点就可以存储4个key

![[Mysql - 优化-2.png]]

B + 树则是在这个数据结构上进行优化

### B+ 树

![[Mysql - 优化-3.png]]

特点
- 非叶子节点不存储数据
  - 所以磁盘读写代价更低
  - 所以查询效率更加稳定
- 叶子节点的数据通过双向链表相互引用
  - 所以便于扫库和区间查询

所以 MySQL 的 InnoDB 引擎采用 B+ 树 的数据结构存储索引更适合，因为
- 阶数更多，路径更短
- 磁盘读写代价更低，非叶子节点只存储指针，而叶子节点存储数据
- 便于扫库和区间查询，因为叶子节点是一个双向链表

## 聚簇索引，非聚簇索引(二级索引)，回表是什么

**聚簇索引**：将数据和索引放在一块，B+树的叶子节点保存的就是整行数据，并且 **必须** 有，且只能有一个

![[Mysql - 优化-4.png]]

聚簇索引规则：
- 如果存在主键，主键索引就是聚簇索引
- 不存在主键就查找唯一索引（UNIQUE）作为聚簇索引
- 如果没有主键也没有唯一索引，InnoDB 会自动生成 rowid 作为隐藏聚集索引

**非聚簇索引(二级索引)**：将数据和索引分开存储，B+树的叶子节点存储的是对应的主键值，可以存在多个

![[Mysql - 优化-5.png]]

这里的二级索引就是非聚簇索引，存储的是对应数据的主键

**回表查询**：就是通过二级索引进行查找时，还需要通过二级索引的对应主键去查找聚簇索引然后获取对应的数据信息

![[Mysql - 优化-6.png]]

这个过程就是
- 通过非聚簇索引(二级索引)找到对应条件的数据的主键(唯一索引)
- 然后通过主键在聚簇索引中查找对应的数据行
这样的回到表中查找的操作就是回表查询

## 覆盖索引

是指使用了索引，并且返回所需要的所有列都可以在该索引中找到，性能会更好一些

![[Mysql - 优化-7.png]]

在这个图中，第三个 SQL 语句属于非覆盖索引，因为需要回表查询

![[Mysql - 优化-8.png]]

也就是说，需要回表查询就不是覆盖索引

覆盖查询的优势有
- 使用 id 查询，直接走聚集索引查询，一次索引扫描就可以直接找到所有数据，性能高
- 如果返回列中没有创建索引，有可能触发回表查询，所以尽量避免 select * 的查询

## MySQL 超大分页处理

当数据量大的时候，如果使用 limit 分页查询，在查询时越往后分页查询效率越低

![[Mysql - 优化-9.png]]

因为这个分页前面 90000010 记录都需要排序，所以查询代价很大

**优化思路**

一般分页查询的时候，通过创建 **覆盖索引** 能够很好的的提升性能，可以通过 **覆盖索引** 加 **子查询** 的形式进行优化。

![[Mysql - 优化-10.png]]

这样就是查询 t 表的索引和排序后的 a 表的聚簇索引，这时就通过覆盖索引完成了这次优化，提高了查询速度

这里的查询是：子查询的 order by 通过 id 这个聚簇索引进行的排序，然后查询再通过 t 表的聚簇索引和子查询 a 表的聚簇索引进行 覆盖索引，这时性能就会比非覆盖索引高

## 索引创建的原则

1. 数据量较大且需要频繁查找的表（数据量>10万）
2. 常作为查询条件、排序、分组的字段
3. 尽量使用联合索引
4. 要控制索引的数量，因为维护索引也需要消耗性能
5. 内容较长使用前缀索引
6. 字段的区分度要高
7. 如果不能存储 null 值，要在创建表时进行 NOT NULL 约束

## 索引失效

是指在某些特定的情况与规则下，索引会“失效”，也就是不通过索引来查询数据，有一下五中情况

1. **违反最左前缀法则**
      
   如果索引了多列，就需要查询从索引的最左列开始，并且中间不能跳过索引中的列   
   ![[Mysql - 优化-11.png|600]]

2. **范围查询右边的列，不能使用索引**   
   ![[Mysql - 优化-13.png]]
   
3. **在索引列上进行运算操作也会导致索引失效**   
   ![[Mysql - 优化-14.png]]

4. **字符串不加单引号会造成索引失效**（类型转换）
   ![[Mysql - 优化-16.png]]
   
5. **以 % 开头的 Like 模糊查询会索引失效，但如果是尾部匹配又不会失效**   
   ![[Mysql - 优化-18.png]]

这些失效的情况都可以通过查询执行计划 explain 进行检查

## SQL 优化的经验

主要有
1. 表的设计优化，数据类型选择
2. 索引优化，索引创建原则
3. SQL 语句优化，避免索引失效，避免使用 SELECT *
4. 主从复制、读写分离，不让写数据影响读数据
5. 分库分表 

![[Mysql - 优化-19.png]]
![[Mysql - 优化-20.png]]
# 事务
## 事务四大特性(ACID)
### 原子性(Atomicity)
 
事务是不可分割的最小操作单元要么全部成功/要么全部失败。
### 一致性(Consistency)

事务完成时，必须使所有的数据都保持一致状态。
### 隔离性(Isolation)

数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
### 持久性(Durability)
 
 事务一旦提交或回滚/它对数据库中的数据的改变就是永久的。

## 并发事务的问题

可能会出现 **脏读** 、**幻读**、**不可重复读** 这些问题，对应的解决方法就是四大隔离级别：读未提交，读已提交，可重复读，串行化

### 脏读

一个事务读到另一个事务还没有提交的数据

比如一个 a 数据当前为 100 ，进程1 的事务要将 a 修改成 101，然后修改成 99，这是一个事务，提交事务之后 a 的最终值应该为 99 ，但此时进程2 读到了没有提交的 a 值为101 ，这时出现的就叫做 **脏读**
![[Mysql - 优化-21.png]]
在以上图中，事务b读取到了事务a没有提交的数据，此时id为1的数据并不是正确的数据

### 不可重复读

一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读

![[Mysql - 优化-22.png]]
在以上的图中就是，事务a第一次读取id为1的数据，此时事务b进行了提交，事务a第二次读取到id为1的数据就不一致了，此时就是不可重复读
### 幻读

当处理了不可重复读之后，一个事务按照条件查询数据时，没有对应的数据行，但插入时这个事务又存在了，但再次获取又是空数据，这就是幻读

![[Mysql - 优化-23.png]]

在上图中，就是幻读

## 事务隔离级别

MySQL 支持的四种标准事务隔离级别：

#### 1. **READ UNCOMMITTED（读未提交）**
   - 最低隔离级别
   - 问题：**脏读、不可重复读、幻读**都可能发生
   - 一个事务可以读取另一个未提交事务的数据

#### 2. **READ COMMITTED（读已提交）**
   - 问题：**不可重复读、幻读**可能发生
   - 一个事务只能读取另一个已提交事务的数据
   - 解决了脏读问题

#### 3. **REPEATABLE READ（可重复读）**
   - MySQL 的**默认隔离级别**
   - 问题：**幻读**可能发生
   - 在同一事务中多次读取同样的数据结果一致
   - 解决了脏读、不可重复读问题

#### 4. **SERIALIZABLE（串行化）**
   - 最高隔离级别
   - **完全解决**了脏读、不可重复读、幻读问题
   - 通过强制事务串行执行，性能最低


## undo log 和 redo log 区别

### redo log

称为重做日志，记录的是事务提交时数据页的物理修改，主要有 重做日志缓冲(redo log buffer) 和 重做日志文件(redo log file)组成，前者在内存中，后者在磁盘中

![[Mysql - 优化-24.png]]

这个文件就可以在服务器突然宕机了之后通过 重做日志文件(redo log file) 进行数据恢复，实现了事务的**持久性**

### undo log

回滚日志，用于记录数据被修改之前的数据，主要作用就是 **提供回滚** 和 **MVCC(多版本并发控制)** 他是一个逻辑回滚
- 当 delete 一条记录是，undo log 就会记录一个 insert 记录
- 当 update 一条记录时，他就会记录一条相反的 update 记录
当机制 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容进行回滚

实现了事务的 **一致性** 和 **原子性**

### undo log 与 redo log 对比

- redo log： 记录的是数据页的物理变化，服务器宕机可以同步数据
- undo log：记录的是数据页的逻辑日志，当事务回滚时，通过逆操作恢复原来的数据
- redo log 保证了事务的 **持久性** ，undo log 保证了事务的 **原子性** 和 **一致性**。

## MVCC 多版本并发控制

**MVCC 多版本并发控制** 是一种提高并发的技术

内部实现中，InnoDB 通过 undo log 保存每条数据的多个版本，并且能够找回数据历史版本给用户读取，每个事务读取的版本可能是不一样的。同一个事务中用户只能看到该事务创建快照之前的已经提交的修改和改事务本身的修改

MVCC 只在 **已提交读**（Read Committed）和**可重复读**（Repeatable Read）这两个隔离级别下工作，不兼容其他两个隔离级别，因为读未提交读取到的总是最新的数据行，而不是符合当前事务版本的数据行，而串行化（Serializable）则会对读的所有数据多加锁。

MVCC 的实现原理主要是依赖每一行的**两个隐藏字段**，**undo log**，**ReadView** 

### MVCC 相关概念

#### 1. 事务版本号

每次事务的开启，都会从数据库获取一个自增的**事务ID**，可以从事务ID判断事务执行的**先后顺序**

也就是当事务开始时，第一件事就是从数据库获得一个自增长的事务ID

#### 2. 隐藏字段

InnoDB 存储引擎中每一行都有两个隐藏列 **trx_id**、**roll_pointer** ，还有一个隐藏列 **row_id** 如果数据表中没有主键和 UNIQUE 建就会创建

| 列名           | 是否必须 | 描述                                 |     |
| ------------ | ---- | ---------------------------------- | --- |
| row_id       | 否    | 单调递增的行ID，不是必需的，占用6个字节。 这个跟MVCC关系不大 |     |
| trx_id       | 是    | **记录操作**该行数据事务的事务ID                |     |
| roll_pointer | 是    | 回滚指针，指向当前记录行的undo log信息            |     |
**记录操作**：指的是 inesrt、update、delete。对于 delete 而言，InnoDB 认为其是一个 update 操作，不过会更新另一个删除位，将行表示为 deleted, 并非真正删除

#### 3. undo log

回滚日志，存储的是老版本的数据。

在修改之前，会将原始数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。也可以通过 undo log 链 找到满足可见性的记录行版本。

在  inesrt、update、delete 操作时，都会产生undo log。

**undo log 的分类**：
- **insert undo log** : 事务对 **insert** 新记录时产生的undo log, 只在事务回滚时需要, 并且在**事务提交后**就可以**立即丢弃**。
- **update undo log** : 事务对记录进行**delete**和**update**操作时产生的undo log，不仅在事务回滚时需要，**快照读**也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被删除。

**undo log 的作用**：
- 事务回滚时保证原子性和一致性
- 如果当前记录行不可见，可以根据 undo log 链找到满足其可见性条件的记录行版本(用于MVCC快照读)。

#### 4. 版本链

多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为**版本链**。

![[Mysql - 优化-25.png]]

#### 5. 快照读和当前读

**快照读**： 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如：

```sql
select * from user where id = 1;
```

**当前读**：读取的是记录数据的最新版本，显式加锁的都是当前读

```sql
select * from user where id = 1 for update;
select * from user where id = 1 lock in share mode;
```

#### 6. ReadView

是事务在进行快照读时生成的**记录快照**，解决可见性问题。

ReadView 保存了当前事务开启时所有**活跃的事务列表**，也就是保存了**不应该**让这个事务看到的其他事务 ID 列表。

**ReadView 的重要属性**
- 

# 未整理

## MySQL 中的分页

MySQL 中实现分页查询使用的是 `LIMIT` 和 `OFFSET` 关键字，而不是 `GROUP BY`。

**基本语法：**
```sql
-- 方式一
SELECT * FROM table_name LIMIT [每页记录数] OFFSET [跳过的记录数];

-- 方式二（简写形式）
SELECT * FROM table_name LIMIT [跳过的记录数], [每页记录数];
```

**示例：**
```sql
-- 获取第3页数据，每页10条（跳过前20条，取10条）
-- 方式一
SELECT * FROM users LIMIT 10 OFFSET 20;

-- 方式二
SELECT * FROM users LIMIT 20, 10;
```

`GROUP BY` 是用于分组聚合操作的关键字，与分页无关。


# 读书
# [[读书 - 《高性能 MySQL》]]
