# 如何定位慢查询

## 开源工具

Arthas、Prometheus、Skywalking
## MySQL 自带慢日志查询

慢日志查询记录了所有执行时间超过指定参数(long_query_time)的 SQL 语句
需要在 MySQL 的配置文件中进行配置 (/etc/my.cnf)

```json
slow_query_log=1 #1为开0为关
long_query_time=2 #秒
```
配置完成后重新启动，检测到慢查询就会记录到`/var/lib/mysql/localhost-slow.log`中

# 分析 SQL 语句执行慢的原因

## 获取 MySQL 执行 SELECT 语句的信息

可以使用 EXPLAIN 或者 DESC 命令获取 MySQL 执行 SELECT 语句的信息

```sql
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件
```

得到的信息是

![[Mysql - 优化.png]]

这里就是这个 SELECT 语句的执行信息，其中一部分字段是需要掌握的，是表示实际使用的索引和执行性能

- possible_key： 可能使用到的索引，这里是 `PROIMARY`

这两个属性可以查看是否命中索引
- key：实际使用的索引
- key_len：索引的实际长度

额外优化建议
- Extra：一共有两个参数，表示额外优化的建议
  ![[Mysql - 优化-1.png]]
  如果发生了 **回表查询** 是可以优化的

用于查看这条 SQL 的连接类型
- type：性能由好到差分别为
  NULL - 无查询
  system - 查询系统中的表
  const - 根据主键查询
  eq_ref - 主键索引查询或者唯一索引查询
  ref - 索引查询
  range - 范围查询
  index - 索引树查询
  all - 全盘扫描

# 索引

## 索引是什么

索引( `index` )是主要是帮助 MySQL 高效获取数据的数据结构(有序)

是一种数据库系统维护的 **满足特定查找算法** 的 **数据结构** （B+树），这种数据结构用某种方式引用数据，这样就可以实现高级的查找算法

具有以下特点
- 提高数据检索效率，降低数据库 IO 成本（不需要全盘扫描）
- 通过索引列对数据进行排序，降低数据排序成本，降低 CPU 负担

## 索引的原理

MySQL 的 InnoDB 存储引擎是使用 B+ 树实现索引结构的

### B 树

是一种多叉路平衡查找树，和二叉树相比有多个分支。

一个最大度数（max-degree）为5阶的b树来说，每一个节点就可以存储4个key

![[Mysql - 优化-2.png]]

B + 树则是在这个数据结构上进行优化

### B+ 树

![[Mysql - 优化-3.png]]

特点
- 非叶子节点不存储数据
  - 所以磁盘读写代价更低
  - 所以查询效率更加稳定
- 叶子节点的数据通过双向链表相互引用
  - 所以便于扫库和区间查询

所以 MySQL 的 InnoDB 引擎采用 B+ 树 的数据结构存储索引更适合，因为
- 阶数更多，路径更短
- 磁盘读写代价更低，非叶子节点只存储指针，而叶子节点存储数据
- 便于扫库和区间查询，因为叶子节点是一个双向链表

## 聚簇索引，非聚簇索引(二级索引)，回表是什么

**聚簇索引**：将数据和索引放在一块，B+树的叶子节点保存的就是整行数据，并且 **必须** 有，且只能有一个

![[Mysql - 优化-4.png]]

聚簇索引规则：
- 如果存在主键，主键索引就是聚簇索引
- 不存在主键就查找唯一索引（UNIQUE）作为聚簇索引
- 如果没有主键也没有唯一索引，InnoDB 会自动生成 rowid 作为隐藏聚集索引

**非聚簇索引(二级索引)**：将数据和索引分开存储，B+树的叶子节点存储的是对应的主键值，可以存在多个

![[Mysql - 优化-5.png]]

这里的二级索引就是非聚簇索引，存储的是对应数据的主键

**回表查询**：就是通过二级索引进行查找时，还需要通过二级索引的对应主键去查找聚簇索引然后获取对应的数据信息

![[Mysql - 优化-6.png]]

这个过程就是
- 通过非聚簇索引(二级索引)找到对应条件的数据的主键(唯一索引)
- 然后通过主键在聚簇索引中查找对应的数据行
这样的回到表中查找的操作就是回表查询

## 覆盖索引

是指使用了索引，并且返回所需要的所有列都可以在该索引中找到，性能会更好一些

![[Mysql - 优化-7.png]]

在这个图中，第三个 SQL 语句属于非覆盖索引，因为需要回表查询

![[Mysql - 优化-8.png]]

也就是说，需要回表查询就不是覆盖索引

覆盖查询的优势有
- 使用 id 查询，直接走聚集索引查询，一次索引扫描就可以直接找到所有数据，性能高
- 如果返回列中没有创建索引，有可能触发回表查询，所以尽量避免 select * 的查询

## MySQL 超大分页处理

当数据量大的时候，如果使用 limit 分页查询，在查询时越往后分页查询效率越低

![[Mysql - 优化-9.png]]

因为这个分页前面 90000010 记录都需要排序，所以查询代价很大

**优化思路**

一般分页查询的时候，通过创建 **覆盖索引** 能够很好的的提升性能，可以通过 **覆盖索引** 加 **子查询** 的形式进行优化。

![[Mysql - 优化-10.png]]

这样就是查询 t 表的索引和排序后的 a 表的聚簇索引，这时就通过覆盖索引完成了这次优化，提高了查询速度

这里的查询是：子查询的 order by 通过 id 这个聚簇索引进行的排序，然后查询再通过 t 表的聚簇索引和子查询 a 表的聚簇索引进行 覆盖索引，这时性能就会比非覆盖索引高

## 索引创建的原则

1. 数据量较大且需要频繁查找的表（数据量>10万）
2. 常作为查询条件、排序、分组的字段
3. 尽量使用联合索引
4. 要控制索引的数量，因为维护索引也需要消耗性能
5. 内容较长使用前缀索引
6. 字段的区分度要高
7. 如果不能存储 null 值，要在创建表时进行 NOT NULL 约束

## 索引失效

是指在某些特定的情况与规则下，索引会“失效”，也就是不通过索引来查询数据，有一下五中情况

1. **违反最左前缀法则**
      
   如果索引了多列，就需要查询从索引的最左列开始，并且中间不能跳过索引中的列   
   ![[Mysql - 优化-11.png|600]]

2. **范围查询右边的列，不能使用索引**   
   ![[Mysql - 优化-13.png]]
   
3. **在索引列上进行运算操作也会导致索引失效**   
   ![[Mysql - 优化-14.png]]

4. **字符串不加单引号会造成索引失效**（类型转换）
   ![[Mysql - 优化-16.png]]
   
5. **以 % 开头的 Like 模糊查询会索引失效，但如果是尾部匹配又不会失效**   
   ![[Mysql - 优化-18.png]]

这些失效的情况都可以通过查询执行计划 explain 进行检查

## SQL 优化的经验

主要有
1. 表的设计优化，数据类型选择
2. 索引优化，索引创建原则
3. SQL 语句优化，避免索引失效，避免使用 SELECT *
4. 主从复制、读写分离，不让写数据影响读数据
5. 分库分表 

![[Mysql - 优化-19.png]]
![[Mysql - 优化-20.png]]
# 事务
## 事务四大特性(ACID)
### 原子性(Atomicity)
 
事务是不可分割的最小操作单元要么全部成功/要么全部失败。
### 一致性(Consistency)

事务完成时，必须使所有的数据都保持一致状态。
### 隔离性(Isolation)

数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
### 持久性(Durability)
 
 事务一旦提交或回滚/它对数据库中的数据的改变就是永久的。

## 并发事务的问题

可能会出现 **脏读** 、**幻读**、**不可重复读** 这些问题，对应的解决方法就是四大隔离级别：读未提交，读已提交，可重复读，串行化

### 脏读

一个事务读到另一个事务还没有提交的数据

比如一个 a 数据当前为 100 ，进程1 的事务要将 a 修改成 101，然后修改成 99，这是一个事务，提交事务之后 a 的最终值应该为 99 ，但此时进程2 读到了没有提交的 a 值为101 ，这时出现的就叫做 **脏读**
![[Mysql - 优化-21.png]]
在以上图中，事务b读取到了事务a没有提交的数据，此时id为1的数据并不是正确的数据

### 不可重复读

一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读

![[Mysql - 优化-22.png]]
在以上的图中就是，事务a第一次读取id为1的数据，此时事务b进行了提交，事务a第二次读取到id为1的数据就不一致了，此时就是不可重复读
### 幻读

当处理了不可重复读之后，一个事务按照条件查询数据时，没有对应的数据行，但插入时这个事务又存在了，但再次获取又是空数据，这就是幻读

![[Mysql - 优化-23.png]]

在上图中，就是幻读

## 事务隔离级别

MySQL 支持的四种标准事务隔离级别：

#### 1. **READ UNCOMMITTED（读未提交）**
   - 最低隔离级别
   - 问题：**脏读、不可重复读、幻读**都可能发生
   - 一个事务可以读取另一个未提交事务的数据

#### 2. **READ COMMITTED（读已提交）**
   - 问题：**不可重复读、幻读**可能发生
   - 一个事务只能读取另一个已提交事务的数据
   - 解决了脏读问题

#### 3. **REPEATABLE READ（可重复读）**
   - MySQL 的**默认隔离级别**
   - 问题：**幻读**可能发生
   - 在同一事务中多次读取同样的数据结果一致
   - 解决了脏读、不可重复读问题

#### 4. **SERIALIZABLE（串行化）**
   - 最高隔离级别
   - **完全解决**了脏读、不可重复读、幻读问题
   - 通过强制事务串行执行，性能最低


## undo log 和 redo log 区别

### redo log

称为重做日志，记录的是事务提交时数据页的物理修改，主要有 重做日志缓冲(redo log buffer) 和 重做日志文件(redo log file)组成，前者在内存中，后者在磁盘中

![[Mysql - 优化-24.png]]

这个文件就可以在服务器突然宕机了之后通过 重做日志文件(redo log file) 进行数据恢复，实现了事务的**持久性**

### undo log

回滚日志，用于记录数据被修改之前的数据，主要作用就是 **提供回滚** 和 **MVCC(多版本并发控制)** 他是一个逻辑回滚
- 当 delete 一条记录是，undo log 就会记录一个 insert 记录
- 当 update 一条记录时，他就会记录一条相反的 update 记录
当机制 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容进行回滚

实现了事务的 **一致性** 和 **原子性**

### undo log 与 redo log 对比

- redo log： 记录的是数据页的物理变化，服务器宕机可以同步数据
- undo log：记录的是数据页的逻辑日志，当事务回滚时，通过逆操作恢复原来的数据
- redo log 保证了事务的 **持久性** ，undo log 保证了事务的 **原子性** 和 **一致性**。

## MVCC 多版本并发控制





# 未整理

## MySQL 中的分页

MySQL 中实现分页查询使用的是 `LIMIT` 和 `OFFSET` 关键字，而不是 `GROUP BY`。

**基本语法：**
```sql
-- 方式一
SELECT * FROM table_name LIMIT [每页记录数] OFFSET [跳过的记录数];

-- 方式二（简写形式）
SELECT * FROM table_name LIMIT [跳过的记录数], [每页记录数];
```

**示例：**
```sql
-- 获取第3页数据，每页10条（跳过前20条，取10条）
-- 方式一
SELECT * FROM users LIMIT 10 OFFSET 20;

-- 方式二
SELECT * FROM users LIMIT 20, 10;
```

`GROUP BY` 是用于分组聚合操作的关键字，与分页无关。


# 读书
# [[读书 - 《高性能 MySQL》]]
