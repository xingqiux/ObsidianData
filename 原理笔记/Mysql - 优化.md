# 如何定位慢查询

## 开源工具

Arthas、Prometheus、Skywalking
## MySQL 自带慢日志查询

慢日志查询记录了所有执行时间超过指定参数(long_query_time)的 SQL 语句
需要在 MySQL 的配置文件中进行配置 (/etc/my.cnf)

```json
slow_query_log=1 #1为开0为关
long_query_time=2 #秒
```
配置完成后重新启动，检测到慢查询就会记录到`/var/lib/mysql/localhost-slow.log`中

# 分析 SQL 语句执行慢的原因

## 获取 MySQL 执行 SELECT 语句的信息

可以使用 EXPLAIN 或者 DESC 命令获取 MySQL 执行 SELECT 语句的信息

```sql
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件
```

得到的信息是

![[Mysql - 优化.png]]

这里就是这个 SELECT 语句的执行信息，其中一部分字段是需要掌握的，是表示实际使用的索引和执行性能

- possible_key： 可能使用到的索引，这里是 `PROIMARY`

这两个属性可以查看是否命中索引
- key：实际使用的索引
- key_len：索引的实际长度

额外优化建议
- Extra：一共有两个参数，表示额外优化的建议
  ![[Mysql - 优化-1.png]]
  如果发生了 **回表查询** 是可以优化的

用于查看这条 SQL 的连接类型
- type：性能由好到差分别为
  NULL - 无查询
  system - 查询系统中的表
  const - 根据主键查询
  eq_ref - 主键索引查询或者唯一索引查询
  ref - 索引查询
  range - 范围查询
  index - 索引树查询
  all - 全盘扫描

## 索引

### 索引是什么

索引( `index` )是主要是帮助 MySQL 高效获取数据的数据结构(有序)

是一种数据库系统维护的 **满足特定查找算法** 的 **数据结构** （B+树），这种数据结构用某种方式引用数据，这样就可以实现高级的查找算法

具有以下特点
- 提高数据检索效率，降低数据库 IO 成本（不需要全盘扫描）
- 通过索引列对数据进行排序，降低数据排序成本，降低 CPU 负担

### 索引的原理

MySQL 的 InnoDB 存储引擎是使用 B+ 树实现索引结构的

#### B 树

是一种多叉路平衡查找树，和二叉树相比有多个分支。

一个最大度数（max-degree）为5阶的b树来说，每一个节点就可以存储4个key

![[Mysql - 优化-2.png]]

B + 树则是在这个数据结构上进行优化

#### B+ 树

![[Mysql - 优化-3.png]]

特点
- 非叶子节点不存储数据
  - 所以磁盘读写代价更低
  - 所以查询效率更加稳定
- 叶子节点的数据通过双向链表相互引用
  - 所以便于扫库和区间查询

所以 MySQL 的 InnoDB 引擎采用 B+ 树 的数据结构存储索引更适合，因为
- 阶数更多，路径更短
- 磁盘读写代价更低，非叶子节点只存储指针，而叶子节点存储数据
- 便于扫库和区间查询，因为叶子节点是一个双向链表

### 聚簇索引，非聚簇索引(二级索引)，回表是什么

**聚簇索引**：将数据和索引放在一块，B+树的叶子节点保存的就是整行数据，并且 **必须** 有，且只能有一个

![[Mysql - 优化-4.png]]

聚簇索引规则：
- 如果存在主键，主键索引就是聚簇索引
- 不存在主键就查找唯一索引（UNIQUE）作为聚簇索引
- 如果没有主键也没有唯一索引，InnoDB 会自动生成 rowid 作为隐藏聚集索引

**非聚簇索引(二级索引)**：将数据和索引分开存储，B+树的叶子节点存储的是对应的主键值，可以存在多个

![[Mysql - 优化-5.png]]

这里的二级索引就是非聚簇索引，存储的是对应数据的主键

**回表查询**：就是通过二级索引进行查找时，还需要通过二级索引的对应主键去查找聚簇索引然后获取对应的数据信息

![[Mysql - 优化-6.png]]

这个过程就是
- 通过非聚簇索引(二级索引)找到对应条件的数据的主键(唯一索引)
- 然后通过主键在聚簇索引中查找对应的数据行
这样的回到表中查找的操作就是回表查询

### 覆盖索引

# 未整理
## 事务四大特性
    
### 原子性(Atomicity)
 
事务是不可分割的最小操作单元要么全部成功/要么全部失败。
            
### 一致性(Consistency)

事务完成时，必须使所有的数据都保持一致状态。
### 隔离性(Isolation)

数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。

### 持久性(Durability)
 
 事务一旦提交或回滚/它对数据库中的数据的改变就是永久的。

## MySQL 中的分页

MySQL 中实现分页查询使用的是 `LIMIT` 和 `OFFSET` 关键字，而不是 `GROUP BY`。

**基本语法：**
```sql
-- 方式一
SELECT * FROM table_name LIMIT [每页记录数] OFFSET [跳过的记录数];

-- 方式二（简写形式）
SELECT * FROM table_name LIMIT [跳过的记录数], [每页记录数];
```

**示例：**
```sql
-- 获取第3页数据，每页10条（跳过前20条，取10条）
-- 方式一
SELECT * FROM users LIMIT 10 OFFSET 20;

-- 方式二
SELECT * FROM users LIMIT 20, 10;
```

`GROUP BY` 是用于分组聚合操作的关键字，与分页无关。

## 事务隔离级别

MySQL 支持的四种标准事务隔离级别：

1. **READ UNCOMMITTED（读未提交）**
   - 最低隔离级别
   - 问题：脏读、不可重复读、幻读都可能发生
   - 一个事务可以读取另一个未提交事务的数据

2. **READ COMMITTED（读已提交）**
   - 问题：不可重复读、幻读可能发生
   - 一个事务只能读取另一个已提交事务的数据
   - 解决了脏读问题

3. **REPEATABLE READ（可重复读）**
   - MySQL 的默认隔离级别
   - 问题：幻读可能发生
   - 在同一事务中多次读取同样的数据结果一致
   - 解决了脏读、不可重复读问题

4. **SERIALIZABLE（串行化）**
   - 最高隔离级别
   - 完全解决了脏读、不可重复读、幻读问题
   - 通过强制事务串行执行，性能最低

**相关问题解释：**
- **脏读**：读取了未提交的数据，对方回滚后数据变无效
- **不可重复读**：同一事务内多次读取，数据被其他事务更改
- **幻读**：同一事务内多次查询，返回的记录数不一致（其他事务插入新记录）

# 读书
# [[读书 - 《高性能 MySQL》]]
