

### 一、为什么 String 被设计为不可变类？

#### [字符串常量池](面试八股%20-%20JVM.md#)（JVM）

#### 1. **安全性（Security）**
   - **线程安全**：  
     String 不可变意味着对象状态不可修改，多线程环境下无需同步即可安全共享。
   - **防止篡改**：  
     String 常用于敏感场景（如文件路径、URL、数据库连接）。若可变，攻击者可能通过修改字符串绕过安全检查。

#### 2. **性能优化（Performance Optimization）**
   - **字符串常量池（String Pool）**：  
     JVM 通过常量池复用字符串，减少内存开销。例如：
     ```java
     String s1 = "Hello"; 
     String s2 = "Hello";  // 复用常量池中的 "Hello"
     ```
     若 String 可变，修改 `s1` 会导致 `s2` 的值意外改变。
   - **哈希值缓存（Hash Caching）**：  
     String 的 `hashCode()` 会缓存哈希值（首次计算后存储），适合作为 `HashMap` 的键。  
     **为什么其他类不缓存？**  
     可变类的哈希值可能变化，缓存会导致不一致，而 String 的不可变性保证了哈希值稳定。


---

### 二、String、StringBuffer、StringBuilder 的区别

| **特性**   | **String**      | **StringBuffer**            | **StringBuilder** |
| -------- | --------------- | --------------------------- | ----------------- |
| **可变性**  | 不可变             | 可变                          | 可变                |
| **线程安全** | 天然线程安全（不可变）     | 线程安全（方法用 `synchronized` 修饰） | 非线程安全（无同步）        |
| **性能**   | 频繁修改时性能差（生成新对象） | 线程安全但性能较低（同步开销）             | 单线程下性能最优（无同步开销）   |

**使用场景**

| **类名**          | **适用场景**                         |
| --------------- | -------------------------------- |
| `String`        | 字符串内容固定且频繁读取（如配置参数、常量）           |
| `StringBuffer`  | 多线程环境下频繁修改字符串（如并发日志拼接）           |
| `StringBuilder` | 单线程环境下频繁修改字符串（如循环体内拼接、动态 SQL 生成） |

- **String 不可变**：安全性、性能优化（常量池、哈希缓存）、设计一致性的综合结果。  
- **三者核心区别**：  
  - `String`：不可变，天然线程安全，适合静态字符串。  
  - `StringBuffer`：可变，线程安全，适合多线程修改。  
  - `StringBuilder`：可变，性能最优，适合单线程修改。

---

### 三、字符串常量池与对象创建

#### 1. **字符串常量池的作用是什么？**
   - **内存优化**：维护不可变字符串的复用，减少重复对象的创建。  
     例如，所有字面量 `"abc"` 都指向常量池中的同一对象。
	
#### 2. **`String s = new String("abc")` 创建的对象数量有几个？**
   - **情况 1**：若常量池已存在 `"abc"` → 堆中创建 **1** 个新对象。  
   - **情况 2**：若常量池不存在 `"abc"` → 先在常量池创建 `"abc"`，再在堆中创建新对象 → **2** 个对象。


### 四、Integer

#### `Integer a = 100; Integer b = 100;` 与 `Integer c = 200; Integer d = 200;` 的比较结果？

这个结果里
a == b 为 true, c == d 为 false,
a.equals(b) 为 true , c.equals(b) 为 true

原因出现在两点，构造 Integer  对象和 Integer 缓存机制

对于缓存机制
- **缓存逻辑**：同一个值多次装箱时，返回缓存中的同一个对象；
- **不同值**：即使都在缓存范围内，不同值的对象依然不同。

首先构造 Integer 对象其本质上是通过 Integer.valueOf() 这个方法，但这个方法结合 Integer缓存机制的情况会出现一个问题，就是缓存的范围是 -128<=value<=127,也就是说，当两个数再这个范围区间并且值相同时，他们指向的时缓存中的同一个对象，，所以 a== b 的值才会一样，但大于这个范围时，他们就是两个对象分别存储，不进入缓存，所以 == 的地址比较就会判断为 false


### 五、Object 类方法  
#### `equals()` 和 `==` 区别？如何正确重写 equals() 和 hashCode()？
**区别：**
   - **`==`**：
     - 对于基本数据类型（如 `int`, `char`），比较的是**值是否相等**。
     - 对于对象类型（如 `String`, 自定义类），比较的是**内存地址**（即是否为同一个对象的引用）。
   - **`equals()`**：
     - 默认行为（未重写时）与 `==` 一致，比较对象的内存地址。
     - 但许多类（如 `String`、`Integer`）重写了 `equals()`，改为比较**对象的内容**是否相等。
     - 自定义类若需实现“值相等”的逻辑，必须重写 `equals()`。
正确重写 equals() 方法：
1. 检查是不是同一个引用地址，就是 == 是否相同
2. 检查参数是否是  Null ,或者类型不匹配
3. 转换目标的类型
4. 逐个比较关键字段是否相同
正确重写 hashCode() 方法
5. 可以通过组合所有关键字段的哈希值，使用 `Objects.hash()` 这个方法


#### 为什么 `wait()`, `notify()`, `notifyAll()` 定义在 Object 类中？
主要是因为他们与内部锁机制绑定，并且所有的对象都可以作为锁

比如在锁机制中，每个对象都有一个 内置锁，wati()，notify() 这些用于线程间协作的必须通过对象锁实现，并且每个对象维护自己的等待队列，线程调用 `obj.wait()` 后，会进入 `obj` 的等待队列，等待其他线程通过 `obj.notify()` 唤醒。

####  六、**异常体系**  
##### Error 和 Exception 的区别？运行时异常和受检异常的区别？
Error和Excpetion都是 Throwable 的子类，但是他们的不同在于，Error 是系统级别的严重错误，通常由 JVM 或底层资源问题引起，应用程序无法处理，只能终止程序，Exception 是属应用运行时可能出现的异常情况，比如 IO 异常或者 空指针异常，可以通过代码捕获和处理

他们的核心区别就是，Error是无法处理的错误，Exception 是程序可处理的异常，Error无法修复，而 Exception可以修复

运行时异常和受检异常：
运行时异常时继承自 RuntimeException 的异常，通常由空指针，下标错位的逻辑代码错误引起，编译时不检查，而受检异常是继承自 Exception 但是不是 RuntimeException 的子类，是编译时进行检查，必须使用 try-catch 捕获或者 throws 声明，否则编译就会失败。

##### `try-catch-finally` 中 finally 的执行时机（含 return 和 System.exit() 场景）？
如论是否发生异常 finally 都会 执行
如果有 return ，则会 先执行 finally 再执行 return
如果 fianlly 中有 return 就会执行  finally 中的 return 从而覆盖之前的返回值 

如果 try 或 catch 之中使用了System.exit() ，则JVM立即终止，finally 不执行


#### 七、**反射机制**  
##### 反射的原理和应用场景？反射如何破坏单例模式？

反射的原理是使用Java提供的运行时动态获取类信息并操作类的能力，主要是通过获取 Class 对象，然后动态创建对象实例，这样就可以通过反射操作 Class 对象实现动态行为

主要的应用有 框架开发，Spring 的依赖注入就属于反射创建 Bean实例，JSON 的序列化和反序列化


##### 如何破坏单例：
是通过获取类的 Class 对象，然后获取私有构造函数，然后暴力破解访问权限 setAccessible(true) ，然后创建实例，就会导致破坏单例的唯一性

但通过 枚举单例法，因为JVM天生保持枚举实例的唯一性，并且反射无法调用枚举的构造函数

#### 八、**Java 8 新特性**  
##### Lambda 表达式与函数式接口的关系？
   - “Lambda 表达式是 Java 8 引入的语法糖，用于简化函数式接口的实现。函数式接口是仅有一个抽象方法的接口，例如 `Runnable`。Lambda 的类型由上下文的目标类型决定，编译器会根据接口的方法签名自动匹配参数和返回类型。例如，`() -> System.out.println("Hi")` 就是一个 `Runnable` 实例。这种设计通过 `invokedynamic` 指令在运行时生成实现类，既简化了代码，又支持了函数式编程范式。”


##### Stream API 的中间操作和终止操作区别？
   - 中间操作如 `filter` 返回新 Stream 并记录操作，但不立即执行；终止操作如 `collect` 触发实际计算。例如，`stream.filter(...).map(...)` 只有遇到 `collect` 时才会遍历数据。这种惰性求值机制通过操作流水线合并和循环融合优化性能，减少中间集合的创建。终止操作执行后流不可复用，确保资源有效管理。”
